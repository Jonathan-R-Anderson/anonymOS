#!/usr/bin/env python3
from __future__ import annotations

import subprocess
from pathlib import Path
import textwrap

def count_source_files(sh_root: Path) -> int:
    return sum(1 for _ in sh_root.joinpath("src").rglob("*.d"))


def count_documented_commands(commands_file: Path) -> int:
    count = 0
    if not commands_file.is_file():
        return 0
    for line in commands_file.read_text(encoding="utf-8", errors="ignore").splitlines():
        if not line:
            continue
        if line.startswith("    "):
            stripped = line.strip()
            if stripped:
                count += 1
    return count


def git_revision(path: Path) -> str:
    try:
        return subprocess.check_output(
            ["git", "-C", str(path), "rev-parse", "HEAD"],
            text=True,
        ).strip()
    except (FileNotFoundError, subprocess.CalledProcessError):
        return "unknown"


def binary_size(sh_root: Path, binary_name: str) -> int:
    candidate = sh_root / binary_name
    if candidate.is_file():
        return candidate.stat().st_size
    return 0


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    sh_root = repo_root / "-sh"
    metadata_path = repo_root / "src" / "sh_metadata.d"

    source_count = count_source_files(sh_root)
    command_count = count_documented_commands(sh_root / "commands.txt")
    revision = git_revision(sh_root)
    binary_name = "lfe-sh"
    binary_bytes = binary_size(sh_root, binary_name)

    module = textwrap.dedent(
        f"""// This file is auto-generated by tools/update_sh_metadata.py
module sh_metadata;

enum string shRepositoryPath = \"/-sh\";
enum string shBinaryName = \"{binary_name}\";
enum string shRevision = \"{revision}\";
enum size_t shSourceFileCount = {source_count}u;
enum size_t shDocumentedCommandCount = {command_count}u;
enum size_t shBinarySizeBytes = {binary_bytes}u;
"""
    )

    metadata_path.write_text(module, encoding="utf-8")


if __name__ == "__main__":
    main()
